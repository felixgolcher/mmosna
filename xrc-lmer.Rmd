---
title: "Exercise for Linear General Mixed Models"
author: "Felix Golcher"
date: "`r format(Sys.time(), '%d %B, %Y %H:%M')`"
bibliography: [packages.bib, glmm.bib]
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
    toc_depth: 6
    number_sections: true
    fig_caption: yes
    table_caption: yes
    df_print: "paged"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE,
                      autodep = TRUE,
                      message = FALSE,
                      warning = FALSE)
knitr::write_bib(file = 'packages.bib')
inputpath <- "data/"
outputpath <- inputpath
contr.sum.flx <- function(n, contrasts = TRUE, sparse = FALSE) 
{
    if (length(n) <= 1L) {
        if (is.numeric(n) && length(n) == 1L && n > 1L) 
            levels <- seq_len(n)
        else stop("not enough degrees of freedom to define contrasts")
    }
    else levels <- n
    levels <- as.character(levels)
    cont <- diag(length(levels))
    if (contrasts) {
        cont <- cont[, -length(levels), drop = FALSE]
        cont[length(levels), ] <- -1
        colnames(cont) <- levels[-length(levels)]
    }
    cont
}
options(contrasts = c(unordered = "contr.sum.flx",
                          ordered= "contr.poly"))

# devtools, I think does not run on windows machine without effor (rTools).
# Install devtools package if necessary
# if(!"devtools" %in% rownames(installed.packages()))
#   install.packages("devtools")

# Install the latest development snapshot from GitHub
# if(!"papaja" %in% rownames(installed.packages())) 
#  devtools::install_github("crsh/papaja@devel")
library(nloptr)
## from https://github.com/lme4/lme4/issues/98:
defaultControl <- list(algorithm="NLOPT_LN_BOBYQA",xtol_rel=1e-6,maxeval=1e5)
nloptwrap2 <- function(fn,par,lower,upper,control=list(),...) {
    for (n in names(defaultControl)) 
      if (is.null(control[[n]])) control[[n]] <- defaultControl[[n]]
    res <- nloptr(x0=par,eval_f=fn,lb=lower,ub=upper,opts=control,...)
    with(res,list(par=solution,
                  fval=objective,
                  feval=iterations,
                  conv=if (status>0) 0 else status,
                  message=message))
}
```

```{r packages, include=FALSE, cache=FALSE}
library(readxl)
library(gridExtra)
library(openxlsx)
library(ggrepel)
library(tidyverse)
library(ggplot2)
library(emmeans)
library(Hmisc)
library(scales)
library(qqplotr)
library(lme4)
library(optimx)
library(nloptr)
library(effects)
# library(papaja)
library(sjPlot)
library(sjlabelled)
library(kableExtra)
library(knitr)
knit_hooks$set(inline =
  function (x) {
      if (is.numeric(x)) {
          x = round(x, getOption("digits"))
          if (x < 1 & x > -1) {
            x = sub("0\\.","\\.",as.character(x)) 
          }

      }
      paste(as.character(x), collapse = ", ")
      }
  )
write_bib(x = .packages(), file="packages.bib")
theme_set(theme_minimal())# +
  # theme(text = element_text(size=3))
tab_model <- function(...){
  sjPlot::tab_model(collapse.ci = T,
                    linebreak = T,
                    digits.p = 3, # not smaller, since bug https://github.com/strengejacke/sjPlot/issues/789
                    show.intercept = F,
                    p.style = "numeric", # numeric seems broken.
                    show.icc = F,
                    show.obs = F,
                    show.ngroups = F,
                    ci.hyphen = ",",
                    ...)#, title = title, collapse.ci = collapse.ci,
                    #linebreak = linebreak, digits.p = digits.p#,
                    # works somehow in the wrong way.
                    # file = paste0(deparse(substitute(...)),".html")
                    #)
}
# at the moment tailored for plotting Situation effect plots.
# we need something more flex. if we want to plot other vars.
ploteff <- function(mod,
                    levels = Sit[sitseq]){
  siteff <- allEffects(mod)$Situation
  siteff %>%
    as_tibble() %>% 
    mutate(across(where(is.numeric), ~ ./exp(siteff$offset)), # siteff = 0 for binom
           Situation = factor(Situation, 
                              levels = levels)) -> sitdat
  ggplot(sitdat, aes(Situation, fit, ymin=lower, ymax=upper))+
    geom_point(size=2)+
    geom_errorbar(width=.4)+
    scale_y_continuous(ifelse(family(mod)$family == "poisson",
                         "Estimated Rate of Occurrence",
                         "Estimated Probability of Occurrence"))+
    coord_trans(y = family(mod)$link)
}
labelcol <- function(v){
  v <- set_label(v,labelmap[cur_column()])
  if(!is.numeric(v)){
    v <- sjlabelled::as_factor(v)
  }
  v
}
ppp <- function(x){
  if(x<.001){
    "<.001"
  } else {
    paste0(" = ",signif(x,1))
  }
}
```

The data are described in the [readme of the data directory](https://scm.cms.hu-berlin.de/golchefe/reflex-pipeline/-/tree/master/data).

### Figure dimensions

The figure width is *globally* set in this code 

```{r}
knitr::opts_chunk$set(fig.width = (myfw <- 7),
                      fig.height = myfw/2)
```


# Prep

```{r}
maindata <- read_excel("data/LengthInWords.xlsx")
metadata <- read_excel("data/LengthInWords-meta.xlsx")
fulldata <- full_join(maindata, metadata)
stopifnot(nrow(fulldata) == nrow(maindata))
stopifnot(ncol(fulldata) == ncol(maindata) + ncol(metadata) -1)
```


# Complexity


## Words

The data don't look very normally distributed:

```{r, echo=FALSE}
fulldata %>% 
  ggplot(aes(Situation, Words#, col=Question
             ))+
  #geom_violin()+
  geom_boxplot()+
  geom_jitter(width = .01)+
  scale_y_sqrt()
```

```{r, include=FALSE}
fulldata %>% 
    group_by(Situation) %>% 
    mutate(Words = scale(Words)) %>% 
    ungroup() %>% 
   ggplot(aes(sample=Words))+
   geom_qq_line()+
   geom_qq()->gg7
```

When we try some standard transformation the $\sqrt{~~}$-Transformation is a clear winner:


```{r, fig.cap="Square root transformed data show pretty normally distributed.", echo=FALSE}
grid.arrange(gg7 + ggtitle("untransformed"),
             (gg7 +
               ggtitle("log transformed")) %+% 
               (fulldata %>% 
                  mutate(Words = log(Words)) %>% 
                  group_by(Situation) %>% 
                  mutate(Words = scale(Words)) %>% 
                  ungroup()),
             (gg7 +
               ggtitle("sqrt transformed")) %+% 
               (fulldata %>% 
                  mutate(Words = sqrt(Words)) %>% 
                  group_by(Situation) %>% 
                  mutate(Words = scale(Words)) %>% 
                  ungroup()),
             (gg7 +
               ggtitle("reverse transformed")) %+% 
               (fulldata %>% 
                  mutate(Words = -1/(Words)) %>% 
                  group_by(Situation) %>% 
                  mutate(Words = scale(Words)) %>% 
                  ungroup()),
             nrow = 2)
```

We did not look at residuals so far, which is what actually has to be normally distributed. But we got a glance that gave us a very good candidate.

```{r}
w0 <- lmer(sqrt(Words) ~ Abi + Situation + (1|TN_ID), data=fulldata)
summary(w0)
```


```{r, echo=FALSE, fig.cap="The Residuals look quite nice"}
data.frame(resid = resid(w0)) %>% 
  ggplot(aes(sample = scale(resid))) + ## qqband wants that... 
  geom_qq_band() +
  geom_qq()+
  geom_qq_line()
```


```{r}
drop1(update(w0, REML = F), test = "Chisq")
```

```{r}
plot(allEffects(w0)[c(1,2)])
```

```{r}
tab_model(w0)
```



## packages

`r paste0("@R-",setdiff(.packages(), c("datasets","grDevices", "graphics", "methods", "stats", "utils")), collapse = ", ")`

# References